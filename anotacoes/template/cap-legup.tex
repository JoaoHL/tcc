%% ------------------------------------------------------------------------- %%
\chapter{LegUp High-Level Synthesis}
\label{cap:legup}

LegUp é um arcabouço \textit{open-source} de síntese de alto nível desenvolvido na Universidade de Toronto (Canadá). Sua síntese converte códigos em C para Verilog e usa algumas ferramentas comerciais como o Quartus Prime II, da Intel, e o Tiger MIPS Processor, da Universidade de Cambridge (Reino Unido). 

Atualmente em sua versão 4.0, seu uso é simples e versátil, além de apresentar uma arquitetura que permite alterações em seus algoritmos, como os de escalonamento e emparelhamento, de maneira descomplicada. Como sua arquitetura usa uma compilação em escopo de funções para implementação em hardware - isto é, ele usa funções como unidade básica para síntese de hardware -, é possível especificar funções para aceleração em hardware enquanto o resto do programa é executado em software; tal técnica é chamada de "fluxo híbrido" pelos criadores da ferramenta.

\section{Fluxo de execução}

\begin{figure}[htb]
	\centering
	\includegraphics[width=13cm]{figuras/legup-flow}
	\caption{\label{fig:graph}Fluxo de execução do LegUp.}
\end{figure}

A figura acima representa o fluxo geral do arcabouço. A entrada do fluxo é um programa desenvolvido em C puro, que é compilado e otimizado pela LLVM, sendo transformado em sua representação intermediária (IR). Em seguida, na fase de alocação, o LegUp usa os dados sobre o \textit{hardware} no qual queremos implementar o algoritmo para alocar os recursos disponíveis no \textit{chip}, tais como blocos de memória e unidades lógicas. Na etapa de escalonamento, as instruções da IR são mapeadas do grafo de controle e fluxo de dados para uma máquina de estados finita, onde cada estado é designado para um ciclo de \textit{clock} específico. Depois esse mapeamento, o algoritmo de síntese atribui, a cada operação da máquina de estados, os recursos do \textit{chip} necessários para sua execução. Com as operações e recursos definidos, o arcabouço gera o RTL equivalente e, por fim, usa esse RTL para criar um arquivo, escrito em Verilog, que o descreve.

\section{Compilação}

O código usada como entrada do arcabouço deve ser escrito em C e possui limitações. A versão gratuita mais recente da ferramenta não suporta funções recursivas, aritmética de ponto flutuante ou alocação dinâmica de memória; entretanto, o LegUp consegue sintetizar estruturas, controles de fluxo, aritmética de inteiros, manipulação de ponteiros (inclusive de funções), dentre outras características da linguagem.

A compilação é feita no \textit{front-end} da LLVM usando o Clang 3.5, pertencente ao projeto LLVM, e cria um arquivo de \textit{bytecode} contendo a LLVM IR correspondente ao programa de entrada. Algumas funções em C que lidam com o manejo da memória (como \texttt{memset} e \texttt{memcopy}, da biblioteca \texttt{string.h}) são compiladas em funções já implementadas pela LLVM, chamadas \textit{funções intrínsecas}. Para contornar a situação, passes do otimizador são executados no código para substituir as funções intrínsecas para funções implementadas manualmente pelo arcabouço, gerando um \textit{bytecode} composto apenas de LLVM IR, sem funções intrínsecas.

\section{Processador}

O processador utilizado pelo arcabouço é o [Tiger MIPS Soft Processor](https://www.cl.cam.ac.uk/teaching/0910/ECAD+Arch/mips.html), um processador que pode ser implementado usando síntese lógica, isto é, seu comportamento pode ser descrito por uma linguagem de descrição de hardware (e.g. Verilog HDL) e posteriormente convertido em um design de hardware. Tal tipo de processador é denominado \textit{softprocessor}. Ele é usado na elaboração do circuito apenas nos fluxos híbrido e puro *software*, onde há a necessidade de um módulo central que comande o funcionamento do circuito. A vantagem de se usar o Tiger é seu código aberto e sua arquitetura RISC, que permitem a adição de novas instruções no processador de maneira muito menos complexa que a arquitetura CISC.

A possibilidade de modificação do processador do circuito é a característica chave do processo de autoavaliação que o LegUp realiza em seu fluxo de execução. Ao adicionar instrumentações para observar a execução do programa, é possível dizer quais instruções são mais utilizadas e por quais funções elas são mais chamadas. Isso permite uma análise extremamente precisa, uma vez que ela é feita a nível de instrução. Outra vantagem é na análise por parte dos usuários, já que o Tiger possui uma documentação de fácil leitura, dada a complexidade do seu funcionamento. Isso dá oportunidade ao usuário de verificar as instruções resultantes da compilação do código em C e otimizá-las manualmente, de acordo com suas necessidades.

Apesar da utilização do Tiger, que é um \textit{softprocessor}, a versão mais recente do LegUp open-source também dá suporte aos processadores *hard processor* da Altera e da Xilinx. Um \textit{hard processor} não pode ser descrito simplesmente por uma HDL e, por isso, seu design é construído de forma rígida no \textit{chip}, como propriedade intelectual. Isso tira a flexibilidade de customização do processador, mas aumenta sua eficiência em termos de energia, latência e área.

%**Nota: a versão mais recente do LegUp, a 5.0, tornou-se comercial. Veja mais [aqui](https://www.legupcomputing.com/main/about#about)**%

Um exemplo de figura está na figura~\ref{fig:graph}.
\begin{figure}[htb]
\includegraphics[width=5cm]{figuras/graph}
\caption{\label{fig:graph}Exemplo de uma figura.}
\end{figure}
