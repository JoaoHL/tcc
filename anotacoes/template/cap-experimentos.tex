%% ------------------------------------------------------------------------- %%
\chapter{Experimentos}
\label{cap:experimentos}

Este capítulo descreve os experimentos feitos com os códigos desenvolvidos, especificando ambientes, configurações e metodologia utilizados para avaliar o desempenho da implementação dos algoritmos em \textit{hardware}, via síntese de alto nível, e \textit{software}.

\section{Metodologia}

\subsection{Configurações dos algoritmos}

Para a execução dos experimentos, entradas específicas foram utilizadas em cada um dos algoritmos. As entradas foram utilizadas igualmente em ambas as implementações em \textit{software} e \textit{hardware}.

O algoritmo de Huffman foi configurado com um texto de $682$ caracteres, parte de um texto de teste chamado \textit{Lorem ipsum}, gerado automaticamente por diversas ferramentas \textit{online}. O alfabeto utilizado foi a tabela ASCII, contendo 128 caracteres (incluindo os não-imprimíveis).

A 2-aproximação do TSP recebeu como entrada o $n = 501$, $n$ sendo o número de vértices do grafo.

\subsection{Implementação em software}

A execução dos algoritmos implementados em \textit{software} foi feita com o uso do \textit{profiler} \textit{oprofile}, disponível no repositório padrão da distribuição Ubuntu do sistema operacional Linux (COLOCAR REFERENCIA). O \textit{oprofile} consegue medir uma contagem aproximada de eventos do processador que ocorrem durante a execução de um programa. No caso deste trabalho, ele foi utilizado para contar a quantidade de ciclos de \textit{clock} executados enquanto o processo especificado estava usando o processador. Apesar do interesse em se medir também o número de acessos à memória, a dificuldade em se instrumentar essa medição nos algoritmos em \textit{hardware} faria com que o resultado não fosse utilizado, devido à falta de dados da execução em \textit{hardware} para comparação.

A compilação dos códigos foi feita usando o compilador da linguagem C \texttt{gcc} versão $5.4.0$, sem nenhuma opção de otimização. A execução foi realizada $15$ vezes via terminal em um computador com processador Intel Core $i5$, com dois núcleos de $1.8$ GHz (totalizando frequência de $3.2$ GHz em programas paralelizáveis), com aproximadamente $10$ \textit{gigabytes} de memória DDR3.

\subsection{Implementação em hardware}

Os códigos C criados no desenvolvimento dos algoritmos descritos foram utilizados como entrada do LegUp no fluxo de puro \textit{hardware}. Não foram utilizadas opções de otimização, como as de compilação do compilador \textit{clang}, ou as de emparelhamento e escalonamento, como \textit{pipelining} de laços ou compartilhamento de unidades funcionais de adição.

Devido à dificuldade em lidar com as saídas serializadas da placa, foram executadas $15$ simulações utilizando a ferramenta \textit{ModelSim}, dispobilizada pela Intel junto da ferramenta de programação de FPGAs \textit{Quartus Prime}. O \textit{ModelSim} foi executado através de uma opção de execução do \textit{Makefile} do LegUp, dada a disponibilidade do arquivo Verilog gerado pela síntese de alto nível.

O \textit{bitcode} gerado pelo fluxo do LegUp foi programado na FPGA a fim de testar se o resultado da síntese era relevante para fins práticos. Após uma pequena modificação no código para acender um LED caso o resultado do algoritmo fosse correto, a placa foi programada e o resultado foi positivo, executando os algoritmos e acendendo o LED dado o resultado correto da execução.

\section{Resultados}

Infelizmente, os resultados dos experimentos foram inconclusivos. Alguns problemas surgiram nessa fase para cada um dos algoritmos, de tal forma que não foi possível comparar a execução das duas implementações de cada um deles.

No algoritmo de Huffman, as simulações do \textit{hardware} foram executadas com sucesso usando a metodologia descrita anteriormente, e os resultados estão descritos na tabela \ref{tabela-simulacao-hardware-huffman}. Nota-se que a variância e o desvio padrão são iguais a $0$, dada a exatidão da simulação dos ciclos de \textit{clock} de um \textit{hardware} e da execução das instruções da máquina de estados do circuito.

A avaliação de desempenho realizada com o \textit{oprofile} no algoritmo de Huffman não gerou resultados conclusivos. A principal razão reside no fato de que a execução do \textit{profiler} com o arquivo compilado do algoritmo, devido à rapidez com que o programa terminava, não conseguiu medir os ciclos de \textit{clock} utilizados pelo processo de forma relevante. O relatório do \textit{profiler} acusava ter medido quantidades em torno de 15 ciclos de \textit{clock}, o que, dada a natureza do algoritmo, não é condizente com o esperado. 

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|} \hline
		Média & Variância & Desvio padrão  \\
		\hline
		12.066 & 0 & 0  \\
		\hline
	\end{tabular}
	\caption{\label{tabela-simulacao-hardware-huffman}Dados da simulação em hardware do algoritmo de Huffman}
\end{table}

O oposto ocorreu no caso da aproximação do TSP. Devido à complexidade do algoritmo, foi possível medir mais precisamente os ciclos de \textit{clock} utilizados pelo arquivo compilado e executado via \textit{software}, apresentando os resultados descritos na tabela \ref{tabela-simulacao-software-tsp}. Na simulação de \textit{hardware}, entretanto, ocorreram problemas de referência de memória não acusados no programa compilado mas acusados no Verilog gerado pelo LegUp, de tal forma que durante a etapa de cálculo do circuito euleriano do grafo, a simulação não terminava. Dessa forma, não foi possível refazer as experiências em tempo hábil usando a placa, devido à falta de conhecimento necessário para visualizar os ciclos de \textit{clock} percorridos até o fim da execução do algoritmo.

\begin{table}[H]
	\centering
	\centering
	\begin{tabular}{|c|c|c|} \hline
		Média & Variância & Desvio padrão  \\
		\hline
		248.013 & 1.032.845 & 1.016,3  \\
		\hline
	\end{tabular}
	\caption{\label{tabela-simulacao-software-tsp}Dados da simulação em software do algoritmo de aproximação do TSP}
\end{table}
