%% ------------------------------------------------------------------------- %%
\chapter{Experimentos}
\label{cap:experimentos}

Este capítulo descreve os experimentos feitos com os códigos desenvolvidos, especificando ambientes, configurações e metodologia utilizados para avaliar o desempenho da implementação dos algoritmos em \textit{hardware}, via síntese de alto nível, e \textit{software}.

\section{Metodologia}

\subsection{Configurações dos algoritmos}

Para a execução dos experimentos, entradas específicas foram utilizadas em cada um dos algoritmos. As entradas foram utilizadas igualmente em ambas as implementações em \textit{software} e \textit{hardware}.

O algoritmo de Huffman foi configurado com um texto de $682$ caracteres, parte de um texto de teste chamado \textit{Lorem ipsum}, gerado automaticamente por diversas ferramentas \textit{online}. O alfabeto utilizado foi a tabela ASCII, contendo 128 caracteres (incluindo os não-imprimíveis). Para testar a ordem de tempo de execução do programa, foram usados textos \textit{Lorem Ipsum} de tamanhos $n$ tais que $n \in {682, 1364, 2782, 5456}$.

A 2-aproximação do TSP recebeu como entrada um número $m$ representando o número de vértices do grafo, tal que $m \in {24, 48, 96, 192}$. 

Devido ao ambiente usado na simulação (uma máquina virtual Java), as simulações demoraram substancialmente, a ponto de demorar $24$ horas e $3$ minutos para $m = 192$. No entanto, os testes foram suficientes para mostrar a curva de crescimento da quantidade de ciclos de \textit{clock} em função do tamanho das entradas.

\subsection{Implementação em software}

A execução dos algoritmos implementados em \textit{software} foi feita com o uso do \textit{profiler} \textit{OProfile}\footnote{\url{http://oprofile.sourceforge.net/news/}}, disponível no repositório padrão da distribuição Ubuntu do sistema operacional Linux. O \textit{OProfile} consegue medir uma contagem aproximada de eventos do processador que ocorrem durante a execução de um programa. No caso deste trabalho, ele foi utilizado para contar a quantidade de ciclos de \textit{clock} executados enquanto o processo especificado estava usando o processador. Apesar do interesse em se medir também o número de acessos à memória, a dificuldade em se instrumentar essa medição nos algoritmos em \textit{hardware} faria com que o resultado não fosse utilizado, devido à falta de dados da execução em \textit{hardware} para comparação.

A compilação dos códigos foi feita usando o compilador da linguagem C \texttt{gcc} versão $5.4.0$, sem nenhuma opção de otimização. A execução foi realizada $15$ vezes via terminal em um computador com processador Intel Core $i5$, com dois núcleos de $1.8$ GHz (totalizando frequência de $3.2$ GHz em programas paralelizáveis), com aproximadamente $10$ \textit{gigabytes} de memória DDR3.

\subsection{Implementação em hardware}

Os códigos C criados no desenvolvimento dos algoritmos descritos foram utilizados como entrada do LegUp no fluxo de puro \textit{hardware}. Não foram utilizadas opções de otimização, como as de compilação do compilador \textit{clang}, ou as de emparelhamento e escalonamento, como \textit{pipelining} de laços ou compartilhamento de unidades funcionais de adição.

Devido à dificuldade em lidar com as saídas serializadas da placa, foi executada $1$ simulação por entrada e por algoritmo, utilizando a ferramenta \textit{ModelSim}, dispobilizada pela Intel junto da ferramenta de programação de FPGAs \textit{Quartus Prime}\footnote{\url{https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/overview.html}}. Inicialmente, mais simulações de \textit{hardware} foram feitas por instância de teste, mas como as medidas iniciais apresentaram variância e desvio padrão iguais a $0$, os testes subsequentes foram executados uma única vez. O \textit{ModelSim}\footnote{\url{https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/model-sim.html}} foi executado através de uma opção de execução do \textit{makefile} do LegUp, dada a disponibilidade do arquivo Verilog gerado pela síntese de alto nível.

O \textit{bitcode} gerado pelo fluxo do LegUp foi programado na FPGA a fim de testar se o resultado da síntese era relevante para fins práticos. Após uma pequena modificação no código para acender um LED caso o resultado do algoritmo fosse correto, a placa foi programada e o resultado foi positivo, executando os algoritmos e acendendo o LED dado o resultado correto da execução.

\section{Resultados}



\begin{table}[htb]
	\centering
	\begin{tabular}{|c|c|c|c|} \hline
		Tamanho do texto (caracteres) & Média (ciclos de \textit{clock}) & Desvio padrão\\\hline
		682 &  816.830  & 29.301,11 \\\hline
		1.364 & 841.969 & 262.462,75 \\\hline
		2.728 & 946.833 & 50.362,63 \\\hline
		5.456 & 990.615 & 315.394,97 \\\hline
	\end{tabular}
	\caption{\label{tabela-simulacao-software-huffman}Dados das execuções do algoritmo de Huffman em software}
\end{table}

\begin{table}[htb]
	\centering
	\begin{tabular}{|c|c|} \hline
		Tamanho do texto (caracteres) & Ciclos de \textit{clock}\\
		\hline
		682 & 12.066 \\\hline
		1364 & 16.158 \\\hline
		2728 & 24.342 \\\hline
		5456 & 40.710 \\\hline
	\end{tabular}
	\caption{\label{tabela-simulacao-hardware-huffman}Dados da simulação em hardware do algoritmo de Huffman}
\end{table}

falar sobre a comparação dos ciclos

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{figuras/grafico-huffman}
	\caption{\label{fig:grafico-huffman}Comparação de ciclos de clock do algoritmo de Huffman entre execuções em software e hardware.}
\end{figure}



\begin{table}[htb]
	\centering
	\begin{tabular}{|c|c|c|} \hline
		Tamanho da entrada (vértices) & Média (ciclos de \textit{clock}) & Desvio padrão\\\hline
		24  & 1.376.867   & 62.074,81 \\\hline
		48  & 4.238.226   & 25.501,12 \\\hline
		96  & 25.392.184  & 174.893,74 \\\hline
		192 & 184.441.878 & 441.135,94 \\\hline
	\end{tabular}
	\caption{\label{tabela-simulacao-software-huffman}Dados das execuções do algoritmo de Huffman em software}
\end{table}

\begin{table}[htb]
	\centering
	\begin{tabular}{|c|c|} \hline
		Tamanho da entrada (vértices) & Ciclos de \textit{clock}\\
		\hline
		24  & 229.790 \\\hline
		48  & 1.405.427 \\\hline
		96  & 9.519.171 \\\hline
		192 & 69.323.457 \\\hline
	\end{tabular}
	\caption{\label{tabela-simulacao-hardware-huffman}Dados da simulação em hardware do algoritmo de Huffman}
\end{table}

\begin{figure}[H]
	\centering
	\includegraphics[width=15cm]{figuras/grafico-tsp}
	\caption{\label{fig:grafico-tsp}Comparação de ciclos de clock do algoritmo de Rosenkrantz-Stearn-Lewis entre execuções em software e hardware.}
\end{figure}