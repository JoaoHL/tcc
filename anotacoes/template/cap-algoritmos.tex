%% ------------------------------------------------------------------------- %%
\chapter{Algoritmos}
\label{cap:algoritmos}

Este capítulo descreve o processo de escolha e desenvolvimento dos algoritmos usados na elaboração deste trabalho. Ambos foram desenvolvidos em linguagem C, sem o uso de bibliotecas externas, e sob as restrições impostas pelo arcabouço LegUp referente às técnicas e recursos da linguagem que poderiam ser utilizadas no fluxo de puro \textit{hardware}.

Tal fluxo foi utilizado devido à mudança radical entre um algoritmo programado para um processador comum, e o mesmo algoritmo rodando puramente em \textit{hardware}. Usar os fluxos híbrido ou de puro \textit{software} trariam muitas semelhanças a sistemas já existentes e, possivelmente, mais eficientes, como sistemas embarcados com uso de microprocessadores (e.g. placas Arduino) ou mesmo um computador pessoal de propósito geral.

\section{Algoritmo de Huffman}

Nos tempos atuais, uma quantidade massiva de dados é produzida diariamente. Por exemplo, estima-se que a rede social Twitter, no segundo quadrimestre de $2018$, possuiu uma média de $335$ milhões de usuários ativos mensais (https://investor.twitterinc.com/static-files/4bfbf376-fefd-43cc-901e-aedd6a7f1daf). Se cada usuário publicar um texto de $140$ caracteres ASCII, que possuem $1$ \textit{byte} cada, serão gerados $46,9$ \textit{gigabytes} em um único instante. Apesar de parecer uma quantia baixa, a hipótese é de que cada usuário publique apenas uma vez no mês, o que é irrealista. Dessa forma, podemos supor que essa rede social, sozinha, produz mensalmente uma quantidade de dados várias ordens de grandeza maiores que isso. Na verdade, estima-se que os servidores do Twitter armazenem cerca de $250$ milhões de publicações por dia (REFERENCIAS AQUI: https://www.quora.com/How-much-data-does-Twitter-store-daily).
	
Essa quantidade de dados pode ser utilizada para aplicações modernas, como análise de sentimentos ou aprendizado de máquina. Ainda assim, é necessário uma forma eficiente de armazená-la e transportá-la. Nesse contexto, surgem os algoritmos de compressão de dados, muito utilizados por \textit{softwares} de compressão de arquivos e por bancos de dados. Dentre tais algoritmos, um é relativamente simples e eficiente para grandes sequências de dados: o algoritmo de Huffman.

\subsubsection{Implementação}

\section{Aproximação do problema do caixeiro viajante}

O problema do caixeiro viajante é um dos problemas de otimização combinatória mais famosos do mundo. Trata-se de um problema NP-Difícil, e ainda não foi encontrado um algoritmo que produza uma solução ótima em tempo polinomial. A formulação abstrata do problema é dada a seguir.\\

\newtheorem*{tsp}{Problema do Caixeiro Viajante}
\begin{tsp}\label{def-tsp}
	Dado um conjunto de cidades, e a distância entre cada par de cidades, qual o menor caminho que deve ser percorrido para que cada cidade seja visitada exatamente uma vez?
\end{tsp}

O problema do caixeiro viajante, ou TSP (do inglês \textit{Travelling Salesman Problem}), é frequentemente modelado usando grafos adirecionados, principalmente para facilitar sua visualização. Neste caso, as cidades são consideradas como vértices de um grafo, e as distâncias entre duas cidades são os pesos das arestas que as conectam. Existem casos específicos do problema, tal como o TSP métrico, cuja definição é\\

\newtheorem*{tsp-metrico}{TSP métrico}
\begin{tsp-metrico}
	Um TSP métrico é um caso particular do problema do caixeiro viajante, tal que o grafo $G = (V,E)$ que o representa possui as seguintes propriedades:
	\begin{itemize}
		\item G é completo, ou seja, $\forall i, j \in V$, $\exists \bar{ij} \in E$
		\item os pesos das arestas de G respeitam a desigualdade triangular, ou seja, $\forall i, j, k \in V$, $p(\bar{ij}) \leq p(\bar{ik}) + p(\bar{kj})$, onde $p(\bar{ij})$ é o peso da aresta $\bar{ij}$.
	\end{itemize}
\end{tsp-metrico}

O caso métrico do TSP surge de forma natural pois, em exemplos reais como visitar todas as cidades de um estado brasileiro, sempre há uma rota entre duas cidades; além disso, percorrer a distância equivalente de uma rota que passa por uma cidade intermediária não deve ser maior do que a rota que vai direto para a cidade destino. Ele foi escolhido para implementação pois além de ser condizente com situações reais, possui um algoritmo de aproximação de tempo polinomial e implementação razoavelmente simples. O algoritmo em questão é uma 2-aproximação do TSP, que calcula um caminho, no máximo, duas vezes mais comprido que o caminho mais curto, como demonstrado em (COLOCAR REFERENCIA AQUI). O algoritmo é descrito em pseudocódigo em \ref{pseudocodigo-aprox-tsp}.\\


\begin{algorithm}[H]\label{pseudocodigo-aprox-tsp}
	\caption{Algoritmo de Rosenkrantz-Stearn-Lewis para TSP métrico}
	\begin{algorithmic}
	\REQUIRE $G = (V,E)$
	\REQUIRE $P = \{p(\bar{ij}), \; \forall i, j \in V\} $

	\STATE $T \gets ArvoreGeradoraMinima(G, P)$
	\STATE $T' \gets T + T$
	\STATE $P \gets CaminhoEuleriano(T')$
	\STATE $C \gets CaminhoHamiltoniano(P)$
	
	\RETURN C\;
	\end{algorithmic}
\end{algorithm}

\subsubsection{Implementação}
